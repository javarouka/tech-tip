# 신규 프로젝트 개발기 - 1

신규 통합 CS 오버뷰 시스템 관리 개발기.

## CS(Customer Service) 관리 프로그램이다!

현재로부터 5년전, 회사에 입사한 뒤로 무려 지금까지 맡게 된 업무는 CS 상담 관리 프로그램이었다.

<!-- 막 입사했을때는 사내 시스템의 MSA(`M`icro `S`ervice `A`rchitecture) 의 시작기였고 개발자 수가 적어 상담 관리 말고도 취소/반품/교환/상품리뷰/마이쿠팡 ... 기타등등을 전부 했었지만 시간이 지나면서 각 롤별로 팀이 나뉘어지고 본격적으로 CS 에만 집중할 수 있는 환경이 만들어졌다. -->

전자상거래 CS 관리 프로그램이라는 건 생각보다 복잡하다.

- 회원정보 조회
- 회원 정보 (아이디, 계좌, 주소지 ...때로는 탈퇴처리) 변경
- 이 회원이 주문한 내역
- 이 회원이 최근 주문한 상품
- 이 회원의 상담 이력
- 상품 판매 업체와 연동
- 택배 연동
- 메시지, 전화 등의 Channel 연동
- etc ...

이런 정보를 통합 관리하는 프로그램이다.

사실상 전자상거래의 모든 도메인이 다뤄진다고 볼 수 있다. 그만큼 의존성이 문어발 식으로 연결되어있고, 그 만큼 타 도메인의 변화에 영향을 많이 받는다.

<p align="center">
    <img src="octocat.png" alt="나...?">
    <br/>
    <em>나 말하나...?</em>
</p>

비유적으로 말하면, 타 도메인에서 재채기를 하면 감기에 걸릴수도 있는게 CS 관리 프로그램이다.

## 버틸수가 없다

MSA(`M`icro `S`ervice `A`rchitecture) 환경에서 동시다발적으로 벌어지는 각 도메인들의 변화를 추적하고 반영하다보면, 쉴새없는 오류와, 호환성 문제를 겪게 된다.

그러면 그럴수록 소주 한병 걸친 운전자가 쓰레기를 가듣 실은 트럭을 타고 시속 200 Km 으로 달리는 상태같은 느낌의 결과물이 나오게 된다. 이 트럭이 사고가 나 전복되기라도 할 경우 실은 쓰레기들이 도로를 가득 메우는 상황이 펼쳐지겠지...

아마 CS 개발자 대부분이 어떤 로직에 추가사항을 넣으려고 할때 *오... 이 코드는 누가 만들었지* 하며 `git blame` 을 (혹은 annotation) 을 안해본 사람이 없을것이다.

(때로는 만든 사람이이 자신인 웃기는 경우도 있다...)

<p align="center">
    <img src="zealot.jpeg" alt="버틸...">
    <br/>
    <em>이 분야의 대부 Zealot</em>
</p>

테스트 코드 부재는 예사이고, 팀원들끼리 충분한 커뮤니케이션이 없으면 중복된 코드가 각자의 개성으로 이곳저곳에서 자라난다.

그 코드가 관련된 도메인이 변할 경우 이곳저곳에서 자란 해당 코드 모두가 수정되어야 한다.
새 기능이 추가될 때 하나라도 이 부분을 누락하면 바로 장애로 이어지거나 유지보수건으로 BTS(업무요청사항) 가 등록된다.

>리팩토링?

리팩토링 범위를 아무리 최소로 해도 하다보면 너무나 광범위한 영역을 다루게 되며 결국 포기하는 일이 많다. 리팩토링이 때로는 새로운 버그를 만들기도 한다. (이건 뭐 다른 상황에서도 마찬가지이지만;) 

이런 환경속에서 부족한 리소스로 일을 진행하면서 몇차례의 개편을 하다보니 코드의 유지보수성에 많은 생각을 하게 되었다.

- 외부 변화에 큰 타격이 없을 것
- 도메인 대응이 늦어도 해당 도메인의 기능을 제외하고는 정상 동작해야 할것
- 새 기능의 추가가 쉬울 것
- 프로그램 속도에 문제가 없을 것
- 재미있을 것(?)

이러한 고민은 회사를 다니면서 내마음 한구석에 항상 있었다.

이런 생각이 정리되어 가던 때에 드디어 다시한번 개편을 시도할 기회가 생기게 되었다.

신규 주문정보의 개편이 시작된 것이다. 이번이 4번째가 된다.

그래서 그동안 고민한 문제들을 쭉 펼쳐보았다.

## 욕심은 많고 ...

### Layer

기존의 구조는 Spring 의 Controller - Service - Repository or Domain API 의 정석적인(?) 구조였다.

평소에 DDD 가 좋다는 이야기를 많이 들은터라 이번 기회에 적용해보려고 이런저런 조사를 했지만, 5년을 넘게 일해도 이해할 수 없는 여러 비즈니스들과 도메인 개념들, 그리고 팀 전체적으로 (나 포함) 낮은 DDD 숙련도 등으로 그냥 전통적인 Controller - Service - Repository or Domain API 로 결정했다.

약간 아쉽기도 하지만, 시간이라는 제약도 있고 익숙하지 않은 모험을 하기에는 약간 위험했다.

다만 저 기본적인 흐름에 레이어링을 적용하기로 했다.

- `Controller`
    - 외부 요청을 처리하는 용도. 일반적인 Controller.
- `Service`
    - 요청에 대한 비즈니스 로직의 묶음. 비즈니스가 변할 경우 서비스만 재작성하면 된다.
    - 여러 비즈니스 단위 모듈 의존성을 주입받아 처리한다. 하나의 의존성만 있을 수 있고, 여러 비즈니스가 얽힌 의존성이 처리될 수도 있다.
- `Business Logic Behavior`
    - 단일 비즈니스를 처리하기 위한 모듈
    - Repository 등에 의존성이 있다.
- `Repository`
    - 데이터에 대한 CRUD 제공과 외부 API 에 대한 래퍼.
    - Repository 와 Api 를 나누려고 했으나 그냥 하나의 레이어로 래핑하기로 함.

Helper 류를 제외한 각 레이어끼리는 의존성을 걸지 않는게 기본이다.

초창기에는 Collector Layer 도 추가했지만, 나중에 설명할 `데이터 토막치기` 덕분에 잘 쓰이지 않아 사장되었다.

Collector 는 각 데이터를 Aggregation 하는 레이어였다.

### DTO

DTO 도 구분했다.

기본적으로 Request 로 받는 Condition 류를 제외한 모든 DTO 에는 모든 필드가 `final` 로 불변객체이다.
 불변이 아닐 경우 각 로직이나 레이어를 거치면서 전달되는 객체의 필드가 실제 값이 있는지, 중간에 값이 어떻게 변하는지한 레이어만 보고서는 추적이 되지 않기 때문이다.

```java
/** 
 * 확장성이 없고 반드시 필요한 순서대로 호출해야만 한다.
 */
// 주문정보를 읽는다
DetailOrderDTO order = this.readOrderData(orderId);

// 주문에 상품정보를 넣는다
order = productModule.appendProductData(order);

// 주문에 업체정보를 넣는다
order = vendorModule.appendVendorData(order);
```

이러한 로직이 있을 경우 `productModule.appendProductData`, `vendorModule.appendVendorData` 는 주문의 특정 필드의 nullable 여부가 중요해진다.
게다가 상품에 업체정보가 있으므로 앞선 로직에서 상품정보가 정상적이지 않을 경우 다음 업체정보도 얻을 수 없게 된다.

필드의 초기화 여부와 각 모듈의 호출 순서까지 모듈 의존성 뿐 아니라 로직 의존성까지 발생한다. 또한 리팩토링 시 각 모듈 호출 순서를 반드시 지켜야하며 각 모듈안의 로직을 자세히 살펴보고 완전히 로직을 파악한 뒤에야 리팩토링을 할 수 있다.

모든 필드가 ```final``` 일 경우(Setter 자체가 존재하지 않음) 어떠한 DTO 를 전달받았을 경우 각 필드들이 반드시 초기화가 되었다는걸 의미하기에 앞선 문제의 대부분이 해소된다.

각 레어이간 데이터는 다음과 같은 기준으로 정했다. 네이밍이 약간 이상한것 같지만 그런가보다 하자;

- `VO`
    - Repository 등에서 얻는 기본 데이터.
- `Condition`
    - Client 의 요청 데이터. 불변처리가 힘들기에 일반적인 Setter 가 달려있다.
- `Form`
    - 비즈니스 로직 단위의 요청 폼. 대부분 서비스에서 생성되어 각 비즈니스 처리기에 전달된다.
- `Result`
    - 각 VO 를 수집하여 Client 가 요구하는 데이터로 빌드되는 DTO

예를 들면, MemberFindCondition 으로 요청되면 서비스는 그 요청으로 각 비즈니스에 MemberFindForm, MemberBlockForm, MemberXXXForm 등을 만들어 처리하고 그 결과를 MemberFoundResult 로 응답한다.

### Data Aggregation

다양한 도메인을 한번에 다루는 CS 특성상 여러 도메인의 데이터를 조합하는 경우가 많다.

어디에도 끼는 회원이나 상품 말고도 CS의 99% 이상의 문의가 주문 관련이니 주문 데이터와 주문에 딸리는 배송 데이터 등은 항상 데이터 조합 대상이다.

기존 시스템은 클라이언트 요청에 각 도메인의 데이터를 한번에 합쳐서 보여주는 방식으로 동작했다. 회원이 최근에 주문한 데이터를 봐야 한다면 회원정보, 주문정보, 상품정보, 배송정보, 취소정보를 읽은 뒤 조합했다.

요청이 하나만 있을 경우에는 이 방법도 나쁘지 않지만, 요청이 겹칠 경우 문제가 될 수 있다.

회원정보 상세를 보여주는 컴포넌트, 최근 주문목록을 보여주는 컴포넌트가 있고 주문목록에서 특정 주문을 선택할 경우 다시 해당 주문의 상세를 보여주는 UI가 있다고 가정한다면,
매 요청의 응답에는 공통적으로 연관 상품정보, 취소정보, 결제정보, 배송정보가 포함되게 된다.

불필요한 반복적 요청이 되는 셈이다.

게다가 비즈니스의 변화로 데이터에 변화가 생길 경우 각 화면별로 더 추가되거나 제거될 수 있어 수정도 동시에 여러 군데에서 일어난다.

이런 방법보다 데이터의 조합은 연관결합도가 높은 것끼리만 하고, 공통적인 데이터는 분할 요청하는 방식을 선택했다.

난 이걸 `데이터 토막치기` 라고 (혼자만의 생각으로) 명명했다.

### 데이터 토막치기

<p align="center">
    <img style="min-width: 320px; max-width: 550px;" src="Dr Salvador.jpg" alt="부우우우우웅!!!">
    <br/>
    <em>토막쳐보자......</em>
</p>

최근주문목록을 조합한다고 가정해보자

1. 회원정보 요청
2. 회원이 주문한 내역 리스트 데이터를 최근 순으로 요청
3. 주문내의 정보로 다음 정보 요청
    - 주문 내의 상품정보로 상품 정보 요청
    - 주문 아이디로 결제 정보 요청
    - 주문 아이디로 취소 정보 요청
4. 상품 정보가 응답되면 그 정보로 다시 업체 정보 요청
5. 상품 정보로 상품의 각 배송타입, 유형, 카테고리 정보 요청

각 정보를 조합해서 화면에 표시한다.

여기서 다시 특정 주문의 상세를 보고 싶다고 한다면 앞서 요청한 상품상세와 각 메타데이터, 업체, 결제, 취소 정보는 요청하지 않아도 된다.
필요한 상세 데이터를 추가 요청한뒤 데이터를 조합하면 끝이다.

(기존이면 위의 플로우를 서버에서 처리하고 있었을 것이다.)

그리고 다른 주문번호를 보다가 다시 같은 주문 상세를 조회할 경우, 이미 로딩된 정보를 활용할 수도 있다.
물론 갱신이 자주 되는 데이터는 만료 관리가 필요하거나 아예 새로 로딩해야 할 때도 있지만, 대부분의 경우 이러한 방식이 훨씬 유리하다.

이렇게 데이터를 최대한 분할하여 재활용성과 서버 자원 낭비를 줄이고 성능 향상도 고려해보기로 했다. 물론 모든 데이터를 토막치는게 아닌 비즈니스나 UI 상황, 효율및 결합도에 따라 데이터 구성을 하여 합치기도 했다.

마침 적용하려고 하는 상태관리기 [Redux](https://lunit.gitbook.io/redux-in-korean/) 의 selector 개념과 이를 보좌해주는 [reselect](https://github.com/reduxjs/reselect) 는 이런 방식에 찰떡궁합이었다.

## 도구들

### 서버 개발

서버 개발에서는 특별한 개선을 하기 어려웠다.

프로젝트를 온전하게 새로 설정했으면 좋았겠지만, 기존부터 쌓인 코드에 의존성이 상당하고 타 팀의 코드도 섞여 있기에 서버의 완전한 새판 짜기는 불가능했다.

패키지와 설정 파일의 분리 정도가 가능했고, 나머지 모듈 의존성 등은 크게 손댈 수 없었다.

### 클라이언트 개발

클라이언트는 이야기가 달라서 완전한 재설정이 가능했다.

클라이언트쪽은 기존의 나쁜 냄새를 모두 제거하기 위해 바닥부터 새로 시작하기로 했다.

기존의 낙후된 webpack 설정 및 의존성을 업그레이드하는걸 시작으로, 서버측을 완전한 Application Database 화를 위해 클라이언트 라우팅을 도입했다.

서버는 그저 요청에 따른 비즈니스를 처리하고, 결과 데이터를 JSON 으로 응답하는걸 전제로 하고, 클라이언트는 주소 파싱으로 사용자가 원하는 컨텐츠를 노출하는 것까지 담당하게 했다. 기존에 라우팅마다 서버에 라우팅 컨트롤러와 뼈대 Template Handlbars 파일이 생기는 방식이 비효율적이라고 생각되었기 때문이다.

<!-- 
## 서버 코드의 레이어링
서비스는 휘발성
실제 비즈니스 로직 1유닛(?)은 Behavior.
요구사항은 애초에 명확할수가 없다. 명확한 요구사항도 시간이 가면 불명확해지는 존재하지 않는 내 여자친구 같은 존재

## Server API 의 난도질
한방 API 는 유지보수성에 장애 VS 성능
타협안은.
문서화가 부족

## Client 군의 반응
난도질당한 서버 API의 통합과 처리.
답은 Reselect

### Redux-Saga

### 라우터와 스토어
결국 라우터 재구현과 스토어의 계층화

### React, Redux, Saga ... Material, Styled-Component
여러 라이브러리들에 얽힌 이야기
${props => props.xxx} 에서 ${props => props.xxx}; 콜론 안붙이면 패망.

## 마무리
좋았다.
전체적인 전지적 작가 시점의 Behavior 설계가 있었다면 더 훌륭한 결과가 나오지 않았을까. 비즈니스 이해라는건 해도해도 어려운 것이다.

서버 API 문서화 실종
아쉬운점은 Style Component 화를 좀더 구체적으로 했다면.
DTO 정의를 좀더 일찍 했다면
Behavior 정의를 좀 더 구체적으로 했다면
컬러는 반드시 변수화 -->